{"./":{"url":"./","title":"前言","keywords":"","body":"1. 前言1. 前言 疫情期间，家中无纸，所以笔记记录在哪里就是个问题，在这个时间我接触到了博客。 最开始的时候，只是想记录在新浪博客上，结果发现新浪博客已经停止注册了，所以就自己建了个博客以记录学习笔记。 但是博客上面的笔记是按照上课来的，太过于零散，后期整理成了一个文档。但是发现过于臃肿，终于在2021年6月，采用gitbook+github的形式重新整理学习笔记。本书是我的学习知识。 数据库 数理金融 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-23 06:25:33 "},"sql/readme.html":{"url":"sql/readme.html","title":"数据库","keywords":"","body":"1. 数据库1. 数据库 一、绪论 1.1数据库系统概述 1.2数据模型相关知识点 1.3数据库系统模式的概念 二、关系数据库 2.1 关系数据结构及形式化定义 2.2 关系操作 2.3 关系的完整性 2.4 关系代数 三、关系数据库标准语言SQL 3.1 SQL概述 3.3 数据定义 3.4 数据查询 3.5 数据更新 3.6 空值的处理 3.7 视图 四、数据库安全性 4.1 数据库安全性概述 4.2 数据库安全性控制 4.3 视图机制 4.4 审计 4.5数据加密 4.6 其他安全性保护 五、数据库完整性 5.1 定义实体完整性 5.2 参照完整性 5.3 用户定义的完整性 5.4 完整性约束命名子句 5.5 断言 5.6 触发器 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:42:26 "},"sql/第一章/":{"url":"sql/第一章/","title":"一、绪论","keywords":"","body":"1. 一、绪论1. 一、绪论 1.1数据库系统概述 1.2数据模型相关知识点 1.3数据库系统模式的概念 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:38:57 "},"sql/第一章/数据库系统概述.html":{"url":"sql/第一章/数据库系统概述.html","title":"1.1数据库系统概述","keywords":"","body":"1. 数据库系统概述1.1. 数据库的基本概念1.1.1. 数据（data）：1.1.2. 数据库（DataBase，DB）：1.1.3. 数据管理系统（DataBase Management System,DBMS）1.1.4. 数据库系统（DataBase System,DBS）1.2. 数据管理技术的产生和发展1.3. 数据库系统的特点1.3.1. 数据结构化1.3.2. 数据的共享性高、冗余度低而且易扩充1.3.3. 数据独立性1.3.4. 数据由数据库管理系统统一管理额控制1. 数据库系统概述 1.1. 数据库的基本概念 1.1.1. 数据（data）： 数据是数据库中出现的基本对象。 描述事物的符号统称为数据。（可以是数字、文字、图形、视频等） 数据的含义称为数据的语义，数据与其语义是密不可分的。 记录是计算机中表示和存储数据的一种格式或者方法。 1.1.2. 数据库（DataBase，DB）： 数据库是长期存储在计算机内，有组织的，可共享的大量数据的集合。 数据库中的数据按照一定的数学模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 特点： 1.永久存储 2.有组织 3.可共享 1.1.3. 数据管理系统（DataBase Management System,DBMS） 数据库管理系统是计算机的基础软件。 其作用是科学的组织和存储数据，高效的获取和维护数据。 其主要功能： 数据定义功能 数据库管理系统提供数据定义语言（Data Definition Language, DDL），用户通过它可以方便的对数据库中的数据对象的组成和结构进行定义。 数据组织、存储和管理 数据库管理系统要分类组织、存储和管理各种数据 数据操纵功能 数据操纵语言（Data Manipulation Language, DML），用户可以进行数据库的基本操作，如查询、插入、修改和删除等 数据库的事务管理和运行管理 保证事物的正确运行，保证数据的安全性、完整性、多用户对数据并发使用以及发生故障后的系统恢复 数据库的建立和维护功能 包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。 其他功能 包括通信功能、数据转换功能、数据库间的互访和互操作功能等。 1.1.4. 数据库系统（DataBase System,DBS） 数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator,DBA）组成的存储、管理、处理和维护数据的系统。 1.2. 数据管理技术的产生和发展 人工管理阶段 文件系统阶段 数据库系统阶段 背景 应用背景 科学计算 科学计算、数据管理 大规模数据管理 硬件背景 无直接存取存储设备 磁盘、磁鼓 大容量 磁盘、磁盘阵列 软件背景 没有操作系统 有文件系统 有数据库管理系统 处理方式 批处理 联机实时处理、批处理 联机实时处理、批处理、分布处理 特点 数据的管理者 用户（程序员） 文件系统 数据库管理系统 数据面向的对象 某一应用程序 某一应用 现实世界（部门、企业、跨国组织等） 数据的共享程度 无共享，冗余度极大 共享性差，冗余度大 共享性高，冗余度小 数据的独立性 不独立，完全依赖于程序 独立性差 具有高度的物理独立性和一定的逻辑独立性 数据的结构化 无结构 记录内有结构、整体无结构 整体结构化，用数据模型描述 数据的控制能力 应用程序自己控制 应用程序自己控制 由数据管理系统提供数据安全性、完整性、并发控制和恢复能力 1.3. 数据库系统的特点 1.3.1. 数据结构化 数据系统实现整体数据结构的结构化，这是数据库的主要特征之一，也是数据库系统和文件系统的本质区别。 整体结构化是指数据库中的数据不再仅仅针对一个应用，而是面向整个组织或者企业 不仅是数据内部是数据化，整体也是数据化，数据之间是有联系的 1.3.2. 数据的共享性高、冗余度低而且易扩充 数据共享可以大大减少数据冗余，节约存储空间。 数据共享还可以避免数据之间额不相容性和不一致性。 并且使得数据库系统弹性大，易于扩充。 1.3.3. 数据独立性 数据独立性是借助数据库管理数据的一个显著优点，包括物理独立性和逻辑独立性。 物理独立性： 用户的应用程序和数据库中的物理存储是相互独立的。 逻辑独立性： 用户的应用程序与数据库的逻辑结构是相互独立的。 1.3.4. 数据由数据库管理系统统一管理额控制 总体来说，数据库是长期储存在计算机被，有组织、大量、共享的数据集合。它可以提供各种用户共享，具有最小的冗余度和较高的数据独立性。数据管理系统在数据库的建立、运用和维护时对数据库进行统一的控制，以保证数据的完整性和安全性，并在多用户同时使用数据库是进行并发控制没在发生故障号对数据库进行恢复。 数据的安全性保护 保护数据以防止不合法使用导致的数据泄密和破坏。 数据的完整性检查 指检查数据的正确性、有效性和相容性。 并发控制 数据库的恢复 数据库管理系统必须要有将数据库从错误状态恢复到某一一致的正确状态（亦称为完整状态或一致状态）的功能，这就是数据库的恢复功能。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第一章/数据模型相关知识点.html":{"url":"sql/第一章/数据模型相关知识点.html","title":"1.2数据模型相关知识点","keywords":"","body":"1. 数据模型相关知识点1.1. 两类数据模型1.1.1. 概念模型1.1.2. 逻辑模型和物理模型1.2. 概念模型1.2.1. 实体（entity）1.2.2. 属性（attribute）1.2.3. 码（key）1.2.4. 实体型（entity type）1.2.5. 实体集（entity set）1.2.6. 联系（relationship）1.3. 数据模型的组成要素1.3.1. 数据结构1.3.2. 数据操作1.3.3. 数据的完整性约束条件1.4. 常用的数据模型1.4.1. 层次模型1.4.2. 网状模型1.4.3. 关系模型1. 数据模型相关知识点 数据模型是对现实世界数据特征的抽象。 数据模型是数据库系统的核心和基础。 1.1. 两类数据模型 1.1.1. 概念模型 概念模型又称为信息模型，按用户的观点对数据和信息建模，主要用于数据库设计 1.1.2. 逻辑模型和物理模型 逻辑模型是按照计算机系统的观点对数据进行建模，主要用于数据库管理系统的实现 物理模型是对数据最底层的抽象。 1.2. 概念模型 Example：（学号，姓名，性别，出生年月，学院，入学年份）表征一个学生 1.2.1. 实体（entity） 客观存在并可相互区分的事物称为实体。【学生】 1.2.2. 属性（attribute） 属性是实体所具有的某一特性。【括号内的数据】 1.2.3. 码（key） 唯一标识实体的属性集被称为码。【学号】（可能是具有标识性的，不同个体必定不同的） 1.2.4. 实体型（entity type） 具有相同属性的实体必然具有共同的特征和性质。 用实体名以及其属性名的集合来抽象和刻画同类实体，称为实体型。 【一个学生（学号，姓名，性别，出生年月，学院，入学年份）】 1.2.5. 实体集（entity set） 同一类型实体的集合【全体学生】 1.2.6. 联系（relationship） 实体之间的联系通常指不同实体集之间的联系。 分为一对一，一对多和多对多 1.3. 数据模型的组成要素 1.3.1. 数据结构 数据结构描述数据库组成对象以及对象之间的联系。 通常按照数据结构的类型来命名数据模型： 层次模型、网状模型和关系模型 1.3.2. 数据操作 数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。 查询、更新（包括插入、修改、删除）两大类操作 数据操作是对系统动态性的描述 1.3.3. 数据的完整性约束条件 数据的完整性约束条件是一组完整性规则。 1.4. 常用的数据模型 1.4.1. 层次模型 IBM公司的IMS系统 最早出现的数据模型 有且只有一个结点并且没有双亲结点，称为根节点 根以外的其他结点有且只有一个双亲结点 每个节点表示一个记录类型，记录类型之间的联系用结点之间的连线表示，所以只能表示父子间的一对多类型。 层析模型像一棵倒立的树，结点的双亲是惟一的 优点： 结构简单并且清晰 查询效率高 提供了良好的技术支持 1.4.2. 网状模型 DBTG系统（CODASYL系统） 允许一个以上的结点没有双亲 一个以上的结点可以有多于一个的双亲 网状模型中子女结点和双亲结点之间的联系不唯一，但是层次模型中两者的联系是唯一的。因此要为每一个联系命名。 优点： 更为直观的描述世界，一个结点可以有多个双亲，结点之间的联系可以有多种 有良好的性能，存储效率高 1.4.3. 关系模型 最重要！！！ 建立在严格的数学概念基础上。 关系模型：由一组关系组成的模型 关系：一个关系对应通常说的一张表 元组：表中的一行 属性：表中的一列 码：也称为码键，表中的某个属性组 分量：元组中的一个属性值 关系模式：对关系的描述 关系模型要求关系必须是规范化的。 关系的每一个分量必须是一个不可分的数据项 优点： 建立在严格的数学基础上 概念单一，无论是实体还是实体之间的联系都用关系来表示。对数据的检索和更新也是关系（即表），所以简单、清晰、易懂易用 存取路径对用户透明，有更高的数据独立性，更好的安全保密性。 关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或者行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个值 非规范性关系 表中有表（大表中嵌有小表） By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第一章/数据库系统模式的概念.html":{"url":"sql/第一章/数据库系统模式的概念.html","title":"1.3数据库系统模式的概念","keywords":"","body":"1. 数据库系统模式的概念1.1. 模式（schema）1.2. 外模式（external schema）1.3. 内模式（internal schema）1.4. 外模式/模式映像1.5. 模式/内模式映像1. 数据库系统模式的概念 数据库系统的三级结构是指数据库系统由外模式、模式和内模式三级构成的。 连线皆是双向箭头 1.1. 模式（schema） 模式也称为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的共享数据视图。 数据库管理系统提供模式数据定义语言（模式DDL）来严格地定义模式 1.2. 外模式（external schema） 外模式也称为子模式，或用户模式，他是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 由外模式DDL来严格定义 1.3. 内模式（internal schema） 内模式又称为存储模式，一个数据库只有一个内模式。是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。 1.4. 外模式/模式映像 当模式改变时，数据库管理员对各个外模式/模式映像进行相应的改变，可以使外模式保持不变。 由于应用程序是依据外模式编写的，所以应用程序不用改动，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性 1.5. 模式/内模式映像 当数据库的存储结构改变的时候，由数据库管理员对模式/内模式进行改变，使得模式保持不变，所以应用程序也不用改变，保证了数据与程序的物理独立性，简称数据的物理独立性。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第二章/":{"url":"sql/第二章/","title":"二、关系数据库","keywords":"","body":"1. 二、关系数据库1. 二、关系数据库 2.1 关系数据结构及形式化定义 2.2 关系操作 2.3 关系的完整性 2.4 关系代数 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:38:34 "},"sql/第二章/2-1.html":{"url":"sql/第二章/2-1.html","title":"2.1 关系数据结构及形式化定义","keywords":"","body":"1. 关系数据结构及形式化定义1.1. 关系1.1.1. 域（domain）1.1.2. 笛卡尔积（cartesian product）1.1.3. 关系（relation）1.1.4. 基本关系的性质1.2. 关系模式1.3. 关系数据库1. 关系数据结构及形式化定义 1.1. 关系 关系模型是建立在集合代数的基础上的。 1.1.1. 域（domain） 域是一组具有相同数据类型的值的集合 e.g.自然数、整数等 1.1.2. 笛卡尔积（cartesian product） 给定一组域D1,D2,⋯,DnD_1,D_2,\\cdots,D_nD​1​​,D​2​​,⋯,D​n​​，允许期中某些域是相同的 笛卡尔积是： D1×D2×D3×⋯×Dn={(d1,d2,d3,⋯,dn)∣di∈Di,i=1,2,3,⋯,n} D_1 \\times D_2 \\times D_3 \\times \\cdots \\times D_n = \\{ ( d_1, d_2, d_3,\\cdots, d_n ) | d_i \\in D_i,i=1,2,3,\\cdots, n\\} D​1​​×D​2​​×D​3​​×⋯×D​n​​={(d​1​​,d​2​​,d​3​​,⋯,d​n​​)∣d​i​​∈D​i​​,i=1,2,3,⋯,n} 每一个(d1,d2,d3,⋯,dn)( d_1, d_2, d_3,\\cdots, d_n)(d​1​​,d​2​​,d​3​​,⋯,d​n​​)称为一个n元组，或者简称元组。 每一个did_id​i​​称为一个分量 一个域允许的不同取值的个数称为这个域的基数（也就是集合中有多少个元素） 笛卡尔积的基数M是Di的基数的乘积 D1D_1D​1​​=……={A,B} D2D_2D​2​​=……={1,2} D3D_3D​3​​=……={a,b,c} D1×D2×D3D_1\\times D_2\\times D_3D​1​​×D​2​​×D​3​​={ ​ (A,1,a),(A,1,b), (A,1,c),(A,2,a),(A,2,b), (A,2,c) ​ (B,1,a),(B,1,b), (B,1,c),(B,2,a),(B,2,b), (B,2,c) ​ } 改笛卡尔积的基数是2×2×3=122\\times2\\times3=122×2×3=12,也就是说，D1×D2×D3D_1\\times D_2\\times D_3D​1​​×D​2​​×D​3​​一共有2×2×3=122\\times2\\times3=122×2×3=12个元组 1.1.3. 关系（relation） 定义在D1×D2×D3×⋯×DnD_1\\times D_2\\times D_3\\times \\cdots \\times D_nD​1​​×D​2​​×D​3​​×⋯×D​n​​上的笛卡尔空间的一个（有限）子集称其为是一个关系，用R(D1,D2,⋯,Dn)R(D_1,D_2,\\cdots,D_n)R(D​1​​,D​2​​,⋯,D​n​​)表示。 字母 含义 R() 关系的名字 n 关系的目或者度（degree） t 关系中的每个元素是关系中的元组 n=1 单元关系/一元关系 n=2 二元关系 关系和笛卡尔积类似，都是一张二维的表，每一列代表一个域（可以相同），每一列去一个名字（称为属性）加以区分。n目代表n个属性。 若某一属性组可以唯一的标识一个元祖，称为候选码 若有多个候选码，选一个作为主码； 若所有属性都是候选码，叫做全码。 候选码的属性：主属性 不包含在任何候选码中的属性：非主属性/非码属性 1.1.4. 基本关系的性质 列是同质的（Homogeneous） 不同的列可出自同一个域；其中的每一列称为一个属性；不同的属性要给予不同的属性名 列的顺序无所谓,，列的次序可以任意交换 任意两个元组的候选码不能相同 行的顺序无所谓，行的次序可以任意交换 分量必须去原子值，即关系的每一个分量必须是一个不可分的数据项 1.2. 关系模式 关系的描述称为关系模式 R(U,D,DOM,F) 字母 表示含义 R 关系名 U 组成该关系的属性名集合 D U中属性所来自的域 DOM 属性向域的映象集合 F 属性间数据的依赖关系的集合 1.3. 关系数据库 关系数据库的型也称为关系数据库模式，是对关系数据库的描述。 关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就成为关系数据库。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第二章/2-2.html":{"url":"sql/第二章/2-2.html","title":"2.2 关系操作","keywords":"","body":"1. 关系操作1.1. 基本的关系操作1.1.1. 查询操作1.1.2. 数据更新1.2. 关系数据语言的分类1. 关系操作 1.1. 基本的关系操作 关系的操作对象都是集合 1.1.1. 查询操作 查询操作包括选择、投影、并、差、笛卡尔积五种基本操作 1.1.2. 数据更新 数据更新操作包括插入、删除和修改 1.2. 关系数据语言的分类 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第二章/2-3.html":{"url":"sql/第二章/2-3.html","title":"2.3 关系的完整性","keywords":"","body":"1. 关系的完整性1.1. 实体完整性1.2. 参照完整性1.3. 用户定义的完整性1. 关系的完整性 1.1. 实体完整性 若属性A是基本关系R的主属性，则A不能取空值。所谓空值是指“不知道”或“不存在”或“无意义”的值。 实体的完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集 现实世界中的实体是可区分的，即他们具有唯一性标识。 相应的，关系模型中以主码作为唯一性标识 主码中的属性即主属性不能取空值 1.2. 参照完整性 设F是基本关系R的一个或者一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。 若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 1.3. 用户定义的完整性 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第二章/2-4.html":{"url":"sql/第二章/2-4.html","title":"2.4  关系代数","keywords":"","body":"1. 关系代数1.1. 传统的集合运算1.1.1. 并（union）1.1.2. 差（except）1.1.3. 交（intersection）1.1.4. 笛卡尔积1.2. 专门的关系运算1.2.1. 选择（selection）1.2.2. 投影（projection）1.2.3. 连接（join）1.2.4. 除运算（division）1.3. 小结1. 关系代数 关系代数的运算可以分为传统的集合运算和关系运算 运算符 符号 含义 集合运算符 U 并 - 差 ∩ 交 × 笛卡尔积 专门的关系运算符 σ 选择 π 投影 ⋈ 连接 ÷ 除 1.1. 传统的集合运算 是二目运算，包括 并、差、交、笛卡尔积四种运算。 1.1.1. 并（union） 由属于R或属于S的元组组成 1.1.2. 差（except） 属于R但是不属于S的元组组成 1.1.3. 交（intersection） 由既属于R又属于S的元组组成 1.1.4. 笛卡尔积 广义的笛卡尔积 R: n目关系，k1k_1k​1​​个元组 S: m目关系，k2k_2k​2​​个元组 R×S 列：（n+m）列元组的集合 元组的前n列是关系R的一个元组 后m列是关系S的一个元组 行： k1×k2 k_1\\times k_2 k​1​​×k​2​​个元组 R×S={trts‾∣tr∈R∧ts∈S} R\\times S= \\{ \\overline{t_r t_s}|t_r\\in R\\land t_s\\in S \\} R×S={​t​r​​t​s​​​​​∣t​r​​∈R∧t​s​​∈S} 1.2. 专门的关系运算 专门的关系运算包括选择、投影、链接、除运算等。 先引入几个记号 R,t∈RR,t\\in RR,t∈R，t[AiA_iA​i​​] 设关系模式为R(A1,A2,⋯,An)R(A_1,A_2,\\cdots ,A_n)R(A​1​​,A​2​​,⋯,A​n​​) 它的一个关系设为R t∈Rt\\in Rt∈R表示t是R的一个元组 t[AiA_iA​i​​]则表示元组t中相应于属性AiA_iA​i​​的一个分量 A,t[A],A‾A,t[A],\\overline{A}A,t[A],​A​​​ 若A={Ai1,Ai2,⋯,Aik}A=\\{A_{i1},A_{i2},\\cdots ,A_{ik}\\}A={A​i1​​,A​i2​​,⋯,A​ik​​},其中Ai1,Ai2,⋯,AikA_{i1},A_{i2},\\cdots ,A_{ik}A​i1​​,A​i2​​,⋯,A​ik​​是A1,A2,⋯,AnA_1,A_2,\\cdots ,A_nA​1​​,A​2​​,⋯,A​n​​中的一部分，则称A为属性列或属性组。 t[A]=(t[Ai1],t[Ai2],⋯,t[Aik])t[A]=(t[A_{i1}],t[A_{i2}],\\cdots ,t[A_{ik}])t[A]=(t[A​i1​​],t[A​i2​​],⋯,t[A​ik​​])表示元组t在属性列A上诸分量的集合。 A‾\\overline{A}​A​​​则表示{A1,A2,⋯,An}\\{A_1,A_2,\\cdots ,A_n\\}{A​1​​,A​2​​,⋯,A​n​​}中去掉{Ai1,Ai2,⋯,Aik}\\{A_{i1},A_{i2},\\cdots ,A_{ik}\\}{A​i1​​,A​i2​​,⋯,A​ik​​}后剩余的属性组。 trts‾\\overline{t_r t_s}​t​r​​t​s​​​​​ R为n目关系，S为m目关系 tr∈R,ts∈St_r\\in R,t_s \\in St​r​​∈R,t​s​​∈S ，trts‾\\overline{t_r t_s}​t​r​​t​s​​​​​ 称为元组的连接 trts‾\\overline {t_r t_s}​t​r​​t​s​​​​​ 是一个n+m列的元组，前n个分量为R中的一个n元组，后m个分量是S中的一个m元组 象集ZxZ_xZ​x​​ 给定一个关系 R(X,Z) ，X,Z是属性组 当t[X]=x时，x在R中的象集为： Zx={t[Z]∣t∈R,t[X]=x}Z_x=\\{t[Z]|t\\in R, t[X]=x \\}Z​x​​={t[Z]∣t∈R,t[X]=x} 它表示R中属性组X上值为x的诸元组在Z上的分量的集合 1.2.1. 选择（selection） 选择又称为限制，是在关系R中寻找符合条件的元组 σF(R)={t∣t∈R∧F(t)=‘真’} \\sigma_F(R)=\\{t|t\\in R\\land F(t)= \\text{‘真’} \\} σ​F​​(R)={t∣t∈R∧F(t)=‘真’} 运算符 符号 含义 集合运算符 > 大于 >= 大于等于 小于 小于等于 = 等于 <> 不等于 集合运算符 ∧ 与 ∨ 或 ¬ 非 1.2.2. 投影（projection） 关系R上的投影是从R中选择出若干属性列组成新的关系。 投影操作是在列的角度进行的运算 投影之后不仅可能取消某些列，还可能取消某些元组（由于重复行的缘故） 1.2.3. 连接（join） R⋈S={trts‾∣tr∈R∧ts∈S∧tr[A]θts[B]} R\\bowtie S=\\{\\overline{t_r t_s}|t_r\\in R\\land t_s\\in S\\land t_r[A]\\theta t_s[B] \\} R⋈S={​t​r​​t​s​​​​​∣t​r​​∈R∧t​s​​∈S∧t​r​​[A]θt​s​​[B]} 从两个关系的笛卡尔积中选取属性间满足一定条件的元组。 A和B：分别为R和S上度数相等且可比的属性组 θ：比较运算符 连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组 两类特殊的连接运算 等值连接 θ为“=”的连接运算称为等值运算 R⋈A=BS={trts‾∣tr∈R∧ts∈S∧tr[A]θts[B]} R\\bowtie _{A=B} S=\\{\\overline{t_r t_s}|t_r\\in R\\land t_s\\in S\\land t_r[A]\\theta t_s[B] \\} R⋈​A=B​​S={​t​r​​t​s​​​​​∣t​r​​∈R∧t​s​​∈S∧t​r​​[A]θt​s​​[B]} 自然连接 自然连接是一种特殊的等值连接 两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉 同时从行和列中进行运算 R⋈S={trts‾[U−B]∣tr∈R∧ts∈S∧tr[B]=ts[B]} R\\bowtie S=\\{ \\overline{t_r t_s}[U-B]|t_r\\in R\\land t_s\\in S\\land t_r[B]=t_s[B] \\} R⋈S={​t​r​​t​s​​​​​[U−B]∣t​r​​∈R∧t​s​​∈S∧t​r​​[B]=t​s​​[B]} 悬浮元组 在做自然连接的时候，关系R中某些元组有可能在S中不存在公共属性相同值的元组，这部分元组就会被舍弃，同样，S中也有部分被舍弃，这些被舍弃的元组就成为悬浮元组。 如果将悬浮元组也保留，其他属性上填NULL就佳作外连接 左外连接 只保留左边关系R中的悬浮元组 右外连接 只保留右边关系S中的悬浮元组 1.2.4. 除运算（division） 给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组。 R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。 R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影： 元组在X上分量值x的象集Yx包含S在Y上投影的集合，记作： Yx ：x在R中的象集，x = tr[X] 除操作是同时从行和列上进行运算的！ 1.3. 小结 关系代数运算：并、差、交、笛卡尔积、投影、选择、连接、除 基本运算：并、差、笛卡尔积、投影、选择 专门关系运算：交、连接、除，可以用5种基本运算来表达，引进它们并不增加语言的能力，但可以简化表达。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 19:05:15 "},"sql/第三章/":{"url":"sql/第三章/","title":"三、关系数据库标准语言SQL","keywords":"","body":"1. 三、关系数据库标准语言SQL1. 三、关系数据库标准语言SQL 3.1 SQL概述 3.3 数据定义 3.4 数据查询 3.5 数据更新 3.6 空值的处理 3.7 视图 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:47:49 "},"sql/第三章/3-1.html":{"url":"sql/第三章/3-1.html","title":"3.1 SQL概述","keywords":"","body":"1. SQL概述1.1. SQL的产生和发展1.2. SQL的特点1.2.1. 综合统一1.2.2. 高度非过程化1.2.3. 面向集合的操作方式1.2.4. 以一种语法结构提供多种使用方式1.2.5. 语言简洁，易学易用1.3. SQL的基本概念1. SQL概述 1.1. SQL的产生和发展 目前，没有任何一个数据库能够支持SQL的所有概念和特性。 同时，雨多软件厂商对SQL基本命令集进行了不同程度的扩展和修改，以支持标准外的一些功能特性 1.2. SQL的特点 1.2.1. 综合统一 数据库的主要功能通过数据库支持的语言来实现。 SQL集数据定义语言。数据操纵语言、数据控制语言的功能于一体，满足以下要求： 定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库； 对数据库中的数据进行查询和更新； 数据库的重构和维护； 数据库安全性、完整性控制，以及事务控制； 嵌入式SQL和动态SQL定义。 1.2.2. 高度非过程化 SQL语言进行操作的时候，只需要提出“做什么”，而无需指明“怎么做”，因此无需了解路径。存储路径的选择以及SQL的操作过程由系统自动完成。 1.2.3. 面向集合的操作方式 菲关系数据模型：操作对象是一条记录 SQL：操作对象一直可以使元组（包括一次插入、删除、更新操作的对象） 1.2.4. 以一种语法结构提供多种使用方式 SQL是独立语言，也是嵌入式语言 1.2.5. 语言简洁，易学易用 1.3. SQL的基本概念 SQL同样支持数据库三级模式结构 外模式：包括若干视图和部分基本表 模式：包括若干基本表 内模式：包括若干存储文件 存储文件的物理结构对最终用户是隐蔽的 视图是从一个或几个基本表导出的表 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 20:36:22 "},"sql/第三章/3-3.html":{"url":"sql/第三章/3-3.html","title":"3.3 数据定义","keywords":"","body":"1. 数据定义1.1. 模式的定义与删除1.1.1. 定义模式1.1.2. 删除模式1.2. 基本表的定义、删除与修改1.2.1. 定义基本表1.2.2. 数据类型1.2.3. 模式与表1.2.4. 修改基本表(alter)1.2.5. 删除基本表1.3. 索引的建立与删除1.3.1. 建立索引1.3.2. 修改索引1.3.3. 删除索引1.4. 数据字典1. 数据定义 SQL的数据定义包括 模式定义、表定义、视图和索引的定义 一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常有多个表、视图和索引等数据库对象。 1.1. 模式的定义与删除 1.1.1. 定义模式 CREATS SCHEMAAUTHORIZATION[||] 1.1.2. 删除模式 DROP SCHEMA 1.2. 基本表的定义、删除与修改 1.2.1. 定义基本表 CREATE TABLE([列级完整性约束条件] [,[列级完整性约束条件]] …… [,] 1.2.2. 数据类型 1.2.3. 模式与表 方法一： 在表名中明显的给出模式名 方法二： 在创建模式语句的时候创建表 方法三： 设置所属模式，这样在创建表的时候不必给出模式名 1.2.4. 修改基本表(alter) ALTER TABLE [ADD[COLUMN][完整性约束]] [ADD] [DROP[COLUMN][CASCADE|RESTRICT（翻译是条件）]] [DROP COSTRAINT[RESTRICT|CASCADES]] [ALTER COLUMN] ADD：增加新列、 新的列级完整性约束条件和新的表级完整性约束条件 DROP COLUMN：删除表中的列： 1.指定了CASCADE：自动删除引用了该列2的对象； 2.指定了RESTRICT：如果该列被其他对象引用，RDBMS（关系数据库管理系统）拒绝删除该列； DROP CONSTRAINT：删除指定的完整性约束条件 ALTER COLUMN：修改原有的列定义，包括修改列名和数据类型 1.2.5. 删除基本表 DROP TABLE[RESTRICT|CASCADE] 1.3. 索引的建立与删除 建立与删除索引由数据库管理员或表的属主（owner），用户不能也不必显示地选择索引 1.3.1. 建立索引 CREATE [UNIQUE] [CLUSTER] INDEXON([][,[]]…); 是要建检索的基本表的名字 每个列名后面可以跟着次序 UNIQUE表名此时索引的每一个索引值只对应唯一一个数据记录 1.3.2. 修改索引 ALTER INDEXRENAME TO 1.3.3. 删除索引 DROP INDEX 1.4. 数据字典 数据字典是关系数据库管理系统内部的一组系统表，他记录了数据库中搜有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。 关系数据库管理系统在执行SQL定义语句的时候，就是在更新字典表中的相关信息 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 20:36:28 "},"sql/第三章/3-4.html":{"url":"sql/第三章/3-4.html","title":"3.4 数据查询","keywords":"","body":"1. 数据查询1.1. 单表查询（只涉及一个表）1.1.1. 选择表中的若干列1.1.2. 选择表中的若干组1.2. 连接查询1.2.1. 等值与非等值连接查询1.2.2. 自身连接1.2.3. 外连接1.2.4. 多表连接1.3. 嵌套查询1.3.1. 带有IN的子查询1.3.2. 带有比较运算符的子查询1.3.3. 带有ANY(SOME)或ALL的子查询1.3.4. 带有EXISTS的子查询1.4. 集合查询1.5. 基于派生表的查询1.6. SELECT语句的一般格式1.6.1. 目标列 表达式 的可选格式1.6.2. 聚集函数的一般格式1.6.3. WHERE子句的条件表达式的可选格式1. 数据查询 SELECT [ALL|DISTINCT][,]… FROM[,…]|()[AS] [WHERE] [GROUP BY[HAVING]] [ORDER BY[ASC|DESC]] 含义： 根据WHERE子句的条件表达式从FROM子句指定的基本表、视图或派生表中找出满足条件的元组，再按照SELECT子句中的目标列表达式选出元组中的属性值形成结果表 1.1. 单表查询（只涉及一个表） 1.1.1. 选择表中的若干列 通过SELECT语句 SELECT FROM 中的各个列的顺序可能与表中的顺序不一致，用户可以自定义显示的顺序 1.1.2. 选择表中的若干组 1. 消除取值重复的行：用DISTINCT语句 SELECT DISTINCT FROM 2.查询满足条件的元组：用WHERE语句 SELECT FROM WHERE 3. ORDER BY子句：查询结果按照某一顺序排列 升序（ASC）降序（DESC） SELECT FROM [ORDER BY[ASC|DESC]] 4.聚集函数 SELECT FROM 5. GROUP BY子句：查询结果按照某一列或者多列的值分组，值相等的为一组 SELECT FROM GROUP BY 1.2. 连接查询 之前的查询针对的是 一个表 ，但是如果针对 两个表 ，那么就成为 连接查询 。 1.2.1. 等值与非等值连接查询 连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词 WHERE[.][.] 比较运算符：= = !=(相当于<>) =:等值连接 其他的:非等值连接 连接谓词中的列名称为连接字段 各连接字段类型必须是可比的，但是不一定相同 WHERE[.]BETWEEN[.]AND[.] 查找方法： 每一个要查找元组 在 总表中从前到后挨个查询，从第一个被查询元祖到最后一个被查询元祖 被称为嵌套循环连接算法（也就是全表扫描） eg. SC表存储学号以及上课信息，student表存储学号以及姓名信息，要求：将两个表合并到一起 方法一： SELECT Student.*,SC* FROM Student,SC WHERE Student.Sno=SC.sno; 方法二： SELSET Student.Sno,Sname,Ssex,Sage,…… FROM Student,SC WHERE Student.Sno=SC.Sno; 根据索引找到对应的SC组，比全表扫描要快 等值连接的重复属性去掉即可称为 自然连接 1.2.2. 自身连接 一个表与自己连接，称为标的 自身连接 eg. 比如查询一门选修课的前置课程 1.2.3. 外连接 两个表连接的时候，可能会出现空值 ，这时候就需要外连接 SELECT Student.Sno…… FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno) 1.2.4. 多表连接 两个以上的表连接 SELECT Student.Sno,Sname,Cname,Grade From Student,SC,Course WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno; 1.3. 嵌套查询 下面的格式称为一个 查询块 SELECT FROM WHERE 将一个查询块插入到另外一个查询块叫做嵌套查询 SELECT /*外层查询或父查询*/ FROM WHERE <> IN ( SELECT /*内层查询或子查询*/ FROM WHERE ) 提示：子查询的SELECT不能使用ORDER BY子句；ORDER BY子句只能用在最终查询 嵌套查询使得用户可以用多个简单查询构成复杂查询 1.3.1. 带有IN的子查询 方法： 先分布来完成此查询，然后再构造嵌套查询（将第一步嵌入第二部） 不相关子查询： 子查询的查询条件不依赖于父查询 相关子查询： 子查询的查询条件依赖于父查询 此时，整个查询语句称为相关嵌套查询 数据库性能调优技术： 实现同一个查询请求可以有很多种方法 ：有些嵌套查询可以用运算代替，有些不可以 1.3.2. 带有比较运算符的子查询 父查询和子查询之间用比较运算符连接 SELECT Sno,Cno FROM SC x /*x是SC的别名，又称为元组变量*/ WHERE Grade >=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); 内层查询是求一个学生的平均成绩 外层查询是查询平均成绩对应的学生 参数x.Sno的值与父查询相关，所以称为 相关子查询 求解相关子查询不能像求解不相关子查询那样 一次性求解子查询在求父查询 必须反复求值 1.3.3. 带有ANY(SOME)或ALL的子查询 比较运算符 含义 >ANY >子查询中的某个值 >=ANY >=子查询中的某个值 =ANY =子查询中的某个值 !=ANY ANY !=子查询中的某个值 >ALL >子查询结果的所有值 >=ALL >=子查询结果的所有值 =ALL =子查询结果的所有值 !=ALL ALL !=子查询结果的所有值 = <> != > >= ANY IN >MIN >=MIN ALL NOT IN >MAX >=MAX eg. =ANY 相当于 IN 1.3.4. 带有EXISTS的子查询 EXISTS表示存在量词 存在 带有 EXISTS 的子查询不返回任何数据，只产生 “true”或“false” SELEXT ... FROM .. WHERE EXISTS ( SELECT ... FROM ... WHERE ... ) 若内层查询结果非空，那么外层的WHERE返回“true”，否则返回“false” 与 EXISTS 相对应的是 NOT EXISTS ，也就是，若是 NOT EXISTS ，啧内层为空值返回“true” eg. 选择了所有的=没有一个不被选择 SQL中没有全称量词，但是可以把带有全称量词的变换为带有存在量词的语句 1.4. 集合查询 集合操作主要包括并操作UNION、交操作INTERSECT和差操作EXCEPT。 1.5. 基于派生表的查询 子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这是子查询生成的临时派生表称为主查询的查询对象。 SELECT Sno,Cno FROM SC,(SELECT …… FROM SC GROUP BY Sno) AS AVG WHERE SC.Sno=AVG. …… 这里面FROM子句中的子查询产生一个新的派生表AVG，主查询将他们两个安学号相等进行连接 有时候AS可以省略 1.6. SELECT语句的一般格式 SELECT [ALL|DISTINCT] [别名][,[别名]]…… FROM [别名][,[别名]]…… |()[AS] [WHERE] [GROUP BY [HAVING]] [GROUP BY [ASS|DESC]] 1.6.1. 目标列 表达式 的可选格式 * .* COUNT([DISTINCT|ALL]*) [.][,[.]]…… 其中：可以使自由属性列、作用于属性列的聚集函数和常量的任意算术运算（加减乘除）组成的运算公式 1.6.2. 聚集函数的一般格式 1.6.3. WHERE子句的条件表达式的可选格式 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 20:35:59 "},"sql/第三章/3-5.html":{"url":"sql/第三章/3-5.html","title":"3.5 数据更新","keywords":"","body":"1. 数据更新1.1. 插入数据1.1.1. 插入元组1.1.2. 插入子查询结果1.2. 修改数据1.3. 删除数据1. 数据更新 数据更新有三种操作： 1.向表中添加若干行数据 2.修改表中数据 3.删除表中若干行数据 1.1. 插入数据 INSERT 1.插入一个元组 2.插入子查询结果（多个元组） 1.1.1. 插入元组 INSERT INTO[([,]...)] VALUES([,]...) /*属性列1的值是常量1；属性列2的值是常量2*/ /*VALUES语句中的字符串常数要用''括起来*/ 1.1.2. 插入子查询结果 INSERT INTO[[,]...] 子查询; 1.2. 修改数据 修改操作又称为更新操作 UPDATE SET=[,=]... [WHERE] 修改满足WHERE子句条件的元组 其中SET子句给出的值用于取代相应属性的列值 如果省略WHERE子句，则表示要修改所有元组 1.3. 删除数据 DELETE FROM [WHERE] DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组 DELETE删除的是表的数据，而不是关于表的定义 可以删除 1.某一个元组的值 2.多个元组的值 3.袋子局查询的删除语句 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 20:40:25 "},"sql/第三章/3-6.html":{"url":"sql/第三章/3-6.html","title":"3.6 空值的处理","keywords":"","body":"1. 空值的处理1.1. 空值的产生1.2. 空值的判断1.3. 空值的约束条件1.4. 控制的算术运算、比较运算和逻辑运算1. 空值的处理 空值：不存在或者不知道或者无意义 空值含有不确定性 1.1. 空值的产生 1.令某一个值是NULL 2.外连接 3.插入元组的时候没有对应数据 1.2. 空值的判断 判断是否是空值，用IS NULL或者IS NOT NULL来判断 1.3. 空值的约束条件 1.属性定义或者域定义中有NOT NULL不能取空值 2.码属性不能取空值 1.4. 控制的算术运算、比较运算和逻辑运算 1.空值与另外一个值(可以使空值)的算术运算的结果是空值 2.空值与另外一个值(可以使空值)的比较运算的结果是UNKNOWN 3.有了UNKNOWN之后，传统的逻辑运算的二值（TRUE,FALSE）变为了三值（T,F,U） 在查询语句中，只有让WHERE和HAVING子句的选择条件为TRUE的才会输出 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 20:41:16 "},"sql/第三章/3-7.html":{"url":"sql/第三章/3-7.html","title":"3.7 视图","keywords":"","body":"1. 视图1.1. 定义视图1.1.1. 建立视图1.1.2. 删除视图1.2. 查询视图1.3. 更新视图1.4. 视图的作用1. 视图 1.1. 定义视图 1.1.1. 建立视图 CREATE VIEW [([,]...)] AS [WITH CHECK OPTION]; 其中，子查询可以是任意的SELECT语句 组成视图的属性列名要么全部指定要么全部省略 以下三种情况必修指定： 某个目标列不是单纯的属性名，是聚集函数或者列表达式 多表连接的时候选出了几个同名列作为视图的字段 需要在视图中为某个列启用更合适的名字 若一个视图侍从单个表中导出的，并且只是去掉了基本表的某些行和某些列，但是保留了主码。则称这列视图是行列子集视图 视图不仅可以建立在一个或者多个基本表上，还可以建立在一个或者多个已经定义好的视图上，或者建立在基本表与视图上 带虚拟列的视图也称为带表达式的视图 带有聚集函数和GROUP BY子句的查询来定义视图，这种视图被称为分组视图 1.1.2. 删除视图 DROP VIEW[CASCADE] 1.2. 查询视图 从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询。然后在执行修正了的查询，这一过程被称为视图消解 WHERE子句不能用聚集函数作为条件表达式，所以执行此修正后的查询将会出现语法错误，可以转化为GROUP BY 定义视图并查询视图 与 基于派生表的查询是有区别的。派生表是暂时的，而视图存在于数据字典中 1.3. 更新视图 视图是不实际存储数据的虚表，对视图的更新最重要转换为对基本表的更新 并不是所有的视图都可以更新 一般的，行列子集视图是可更新的 不可更新视图≠不允许更新视图 1.4. 视图的作用 1.简化用户的操作 2.使用户能以所种角度看待同一数据 3.随重构数据库提供了一定程度的逻辑独立性 4.对机密数据提供安全保护 5.适当利用视图可以更清理的表达查询 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 20:42:21 "},"sql/第四章/":{"url":"sql/第四章/","title":"四、数据库安全性","keywords":"","body":"1. 四、数据库安全性1. 四、数据库安全性 4.1 数据库安全性概述 4.2 数据库安全性控制 4.3 视图机制 4.4 审计 4.5数据加密 4.6 其他安全性保护 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:48:56 "},"sql/第四章/4-1.html":{"url":"sql/第四章/4-1.html","title":"4.1 数据库安全性概述","keywords":"","body":"1. 数据库安全性概述1.1. 数据库的不安全因素1. 数据库安全性概述 数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄漏、更改或破坏 1.1. 数据库的不安全因素 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄露 安全坏境的脆弱性 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 22:02:57 "},"sql/第四章/4-2.html":{"url":"sql/第四章/4-2.html","title":"4.2 数据库安全性控制","keywords":"","body":"1. 数据库安全性控制1.1. 用户身份鉴别1.2. 存取控制1.3. 自动存取控制1.4. 授权：授予与收回1.4.1. GRANT1.4.2. REVOKE1.5. 数据库角色1.6. 强制存取控制方法1. 数据库安全性控制 1.1. 用户身份鉴别 静态口令鉴别 动态口令鉴别 生物特征鉴别 智能卡鉴别 1.2. 存取控制 存取控制机制主要包括定义用户权限和合法权限检查两部分 定义用户权限和合法权限检查极值一起组成了数据库管理系统的存取控制子系统。 存取控制包括自动存取控制和强制存取控制 1.3. 自动存取控制 用户权限是由两个要素组成的：数据库对象和操作类型 在数据库系统中，定义存取权限称为授权 存取控制的对象不仅有数据本身（包括基本表中的数据、属性列上的数据），还有数据库模式（包括模式、基本表、视图和索引的创建等） 对象类型 对象 操作类型 数据库模式 模式 CREATE SCHEMA 基本表 CREATE TABLE;ALTER TABLE 视图 CREATE TABLE 索引 CREATE INDEX 专门的关系运算符 基本表和视图 SELECT; INSERT; UPDATE; DELETE; REFERENCES; ALL PRIVILEGES 属性列 SELECT; INSERT; UPDATE; REFERENCES; ALL PRIVILEGES 1.4. 授权：授予与收回 1.4.1. GRANT GRANT [,] ON [,] TO[,] [WHITH FRANT OPTION] 1.4.2. REVOKE REVOKE [,] ON [,] FROM [,]...[CASCADE|RESTRICT] 用户可以自主的决定将数据的存储权限权限授予给别人，也可以决定将授权的权限授予别人，因此可以称这样的存取控制是自主存取控制 1.5. 数据库角色 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。 角色的创建 CREATE ROLE 给角色授权 GRANT[,] ON对象名 TO[,] 讲一个角色授予其他角色或者用户 GRANT[,] TO[,] [WHITH ADMIN OPTION] 角色权限的收回 REVOKE [,] ON [,] FROM [,]...[CASCADE|RESTRICT] 1.6. 强制存取控制方法 主体：系统中的活动实体，包括数据库管理系统所管理的实际用户和代表用户的各进程 客体：系统中的被动实体，受主体操纵，包括文件、基本表、索引、视图等 对于主体和客体，数据库管理系统为他们每个实例指派一个敏感度标记 敏感度分为：绝密(TS)、机密(S)、可信(C)、公开(P) 密级次序：TS>=S=P 规则： 仅当 主体>=客体 主体才能读取客体 仅当 主体 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 22:04:34 "},"sql/第四章/4-3.html":{"url":"sql/第四章/4-3.html","title":"4.3 视图机制","keywords":"","body":"1. 视图机制1. 视图机制 可以为不同的用户定义不同的视图，并把数据的对象限制在一定范围内 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 22:06:54 "},"sql/第四章/4-4.html":{"url":"sql/第四章/4-4.html","title":"4.4 审计","keywords":"","body":"1. 审计1. 审计 审计功能把用户对数据库的所有操作自动记录下来放入审计日志中，审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间、内容等。 审计事件(服务器事件、系统权限、语句时间、模式对象事件) 审计功能(基本功能、提供多套审计规划、提供审计分析和报表功能、审计日志管理) AUDIT语句和NOAUDIT语句 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 22:05:01 "},"sql/第四章/4-5.html":{"url":"sql/第四章/4-5.html","title":"4.5数据加密","keywords":"","body":"1. 数据加密1.1. 存储加密1.2. 传输加密1. 数据加密 加密的思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式——密文，从而使得不知道解密算法的人无法获知数据的内容 数据加密主要包括存储加密和传输加密 1.1. 存储加密 提供透明和非透明两种存储加密形式 透明：内核级加密保护；对用户完全透明；在数据写到次哦按时进行加密，授权用户读取的时候进行解密 非透明：通过多个加密函数实现 1.2. 传输加密 保证数据库用户和服务器之间的安全数据交换，数据库关系里头提供了传输加密功能 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 22:07:46 "},"sql/第四章/4-6.html":{"url":"sql/第四章/4-6.html","title":"4.6 其他安全性保护","keywords":"","body":"1. 其他安全性保护1. 其他安全性保护 推理控制 隐蔽信道 数据隐私保护 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-20 22:05:47 "},"sql/第五章/":{"url":"sql/第五章/","title":"五、数据库完整性","keywords":"","body":"1. 五、数据库完整性1. 五、数据库完整性 数据库的完整性是指数据的正确性和相容性 提供定义完整性约束条件的机制 提供完整性检查的方法 进行违约处理 关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。 5.1 定义实体完整性 5.2 参照完整性 5.3 用户定义的完整性 5.4 完整性约束命名子句 5.5 断言 5.6 触发器 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:49:45 "},"sql/第五章/5-1.html":{"url":"sql/第五章/5-1.html","title":"5.1 定义实体完整性","keywords":"","body":"1. 定义实体完整性1.1. 实体完整性检查和违约处理1. 定义实体完整性 1.1. 实体完整性检查和违约处理 用 PRIMARY KEY 短语定义了关系主码之后，用户每插入一条记录或者对主码列更新的时候，关系数据库将进行实体完整性规则自动进行检查： 检查主码是否唯一，如果不唯一啧拒绝插入或者修改 检查主码的各个属性是否为 NULL ，只要有一个为 NULL 就拒绝插入或者修改 检查方法： 全表扫描，依次判断每一条记录 但是十分耗时 在主码上自动建立一个索引 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:26:31 "},"sql/第五章/5-2.html":{"url":"sql/第五章/5-2.html","title":"5.2 参照完整性","keywords":"","body":"1. 参照完整性1.1. 定义参照完整性1.2. 参照完整性检查和违约处理1. 参照完整性 1.1. 定义参照完整性 CREATE TABLE ... (SNO CHAR(9) NOT NULL/*主码不能是NULL*/ CNO CHAR(7) NOT NULL ..... PRIMARY KEY (SNO,CNO)/*在表级定义实体完整性*/ FOREIGN KEY (SNO) REFERENCES Student(SNO)/*在表级定义参照完整性*/ FOREIGN KEY (CNO) REFERENCES Course(CNO)/*在表级定义参照完整性*/ ) 1.2. 参照完整性检查和违约处理 被参照表（例如student） 参照表（例如SC） 若违约则处理方法 正常操作 可能破坏参照完整性 --- 插入元组 拒绝 (1) 可能破坏参照完整性 --- 修改外码值 拒绝 (2) 删除元组 ----- --->可能破坏参照完整性 拒绝/级联删除/设置为空值 (3) 修改主码值 ----- --->可能破坏参照完整性 拒绝/级联修改/设置为空值 (4) (1)SC表中增加一个元组，该元组的主码 SNO 属性值在student表中找不到一个元组使其 SNO 值与之相等 (2)修改SC表的一个元组，修改后该元组的主码 SNO 属性值在student表中找不到一个元组使其 SNO 值与之相等 (3)从student表中删除一个元组，造成SC表中某些元组的SNO属性值在student表中找不到一个元组，（其SNO属性值与被删除的相等） (4)修改student表中一个元组的SNO属性值，造成SC表中某些元组的SNO属性值在student表中找不到一个元组，（其SNO属性值与被删除的相等） 当上述的不一致发生时，三种策略： 拒绝(NO ACTION)：不允许该操作执行，该策略一般设置为默认策略 级联(CASCADE)：当删除或者修改被参照表student的一个元祖导致与参照表SC的不一致时，删除或者修改参照表中所有导致不一致的元组 eg. 相当于同时删除student和SC表中的相同元组 设置为空值：当删除或者修改被参照表student的一个元祖导致与参照表SC的不一致时，将参照表中所有造成不一致的元组的对应属性值设置为 空值 。 eg. CREATE TABLE SC (SNO CHAR(9) NOT NULL/*主码不能是NULL*/ CNO CHAR(7) NOT NULL Grade SMALLINT, PRIMARY KEY (SNO,CNO)/*在表级定义实体完整性*/ FOREIGN KEY (SNO) REFERENCES Student(SNO)/*在表级定义参照完整性*/ ON DELETE CASCADE /*当删除Student中的元组时，级联删除SC表中的相应元组*/ ON UPDATE CASCADE /*当更新Student中的SNO时，级联更新SC表中的相应元组*/ FOREIGN KEY (CNO) REFERENCES Course(CNO)/*在表级定义参照完整性*/ ON DELETE NO ACTION /*当删除Course表中的元组造成与SC表中的不一致时，拒绝删除*/ ON UPDATE CASCADE /*当更新Student中的SNO时，级联更新SC表中的相应元组*/ ) By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:26:27 "},"sql/第五章/5-3.html":{"url":"sql/第五章/5-3.html","title":"5.3 用户定义的完整性","keywords":"","body":"1. 用户定义的完整性1.1. 属性上的约束条件1.2. 元组上的约束条件1. 用户定义的完整性 针对某一具体应用的数据必须满足的语义要求就是用户定义的完整性 1.1. 属性上的约束条件 1.属性上的约束条件的定义 列值非空(NOT NULL) CREATE TABLE ... (SNO CHAR(9) NOT NULL/*主码不能是NULL*/ CNO CHAR(7) NOT NULL ..... PRIMARY KEY (SNO,CNO)/*在表级定义实体完整性,并且此句隐含了SNO ,CNO不能取空值，此 时上面的SNO和CNO的NOT NULL可以不写*/ ) 列值唯一(UNIQUE) CREATE TABLE ... (SNO CHAR(9) UNIQUE NOT NULL /*SNO唯一，并且不能是NULL*/ CNO CHAR(7) NOT NULL ) 检查列值是否满足一个条件表达式(CHECK短句) CREATE TABLE ... (SNO CHAR(9) NOT NULL CNO CHAR(7) NOT NULL Ssex CHAR(2) CHECK(Ssex IN('男','女'))/*该属性只能从男、女中选择*/ ) 2. 属性上的约束条件的检查和违约处理 1.2. 元组上的约束条件 1.元组上约束条件的定义 与属性上的约束条件的定义类似： 元组上约束条件的定义 在CREATE TABLE中用 CHECK 语句定义元组的约束条件 CREATE TABLE ... (SNO CHAR(9) NOT NULL Sname CHAR(7) NOT NULL Ssex CHAR(2) CHECK(Ssex='女' OR Sname NOT LIKE 'Ms.%')/*学生性别是男的时候，起名字不能用Ms开 头*/ ) 2. 元组上的约束条件的检查和违约处理 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:26:24 "},"sql/第五章/5-4.html":{"url":"sql/第五章/5-4.html","title":"5.4 完整性约束命名子句","keywords":"","body":"1. 完整性约束命名子句1.1. 完整约束命名子句1.2. 修改表中的完整性限制1. 完整性约束命名子句 完整性约束条件不仅可以在CREATE TABLE语句中定义，还在CREATE TABLE中提供了完整约束命名子句CONSTRAINT，用来针对完整性约束条件命名。 1.1. 完整约束命名子句 COMSTRAINT 包括 NOT NULL ; UNIQUE ; PRIMARY KEY ; FOREIGN KEY ; CHECK 短语等 1.2. 修改表中的完整性限制 可以使用ALTER TABLE 语句修改表中的完整性限制 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:26:19 "},"sql/第五章/5-5.html":{"url":"sql/第五章/5-5.html","title":"5.5 断言","keywords":"","body":"1. 断言1. 断言 创建断言的语句格式 CREATE ASSERTION 每个断言都被赋予一个名字，中的约束条件与WHERE子句的条件表达式类似 删除断言的语句格式 DROP ASSERTION By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:26:14 "},"sql/第五章/5-6.html":{"url":"sql/第五章/5-6.html","title":"5.6 触发器","keywords":"","body":"1. 触发器1.1. 定义触发器1.2. 激活触发器1.3. 删除触发器1. 触发器 触发器trigger是用户定义在关系表上的一类由事件驱动的特殊过程。 1.1. 定义触发器 触发器又叫做事件—条件—动作规则 当特定的系统事件（对一个表的增删改操作，事件的结束等）发生时，对规则的条件进行检查，如果条件成立则制定规则中的动作，否则不执行。 CREATE TRIGGER /*每当触发事件发生时，该触发器被激活*/ {BEFORE|AFTER} ON /*指明触发器激活时间是在执行出发事件前或后*/ REFERENCING NEW|OLD ROW AS /*用referencing指出引用的变量*/ FOR EACH {ROW|STATEMENT}/*定义出发的类型，指明动作体执行的频率*/ [WHERE ]/*仅当触发条件为真时才执行触发动作体*/ 1.2. 激活触发器 执行顺序： 执行该表上的 before 触发器 激活触发器的sql语句 执行该表上的 after 触发器 1.3. 删除触发器 DROP TRIGGER ON By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-06-21 07:26:10 "},"数理金融/readme.html":{"url":"数理金融/readme.html","title":"数理金融","keywords":"","body":"1. 数理金融1. 数理金融 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-23 06:26:48 "},"数理金融/fan-1.html":{"url":"数理金融/fan-1.html","title":"数理金融（一）","keywords":"","body":"1. 数理金融（一）1.1. 远期合约1.2. 期货1.3. 期权1.4. 期权分类1.4.1. 5.交易者类型1.5. 利率1. 数理金融（一） 数理金融相关名词 1.1. 远期合约 在时刻 t 签定的一份合同 将在时刻T以设定的价格进行笔交易，称为在[t,T]上的一个远期合约. 名称 含义 原生资产/标的资产 合约中的物品 交割价格/远期价格 设定的成交价格 交割日 时刻T 空头 卖方 多头 买方 在签订合约的当天，客户不需要付出成本 在交割日，该合约必需生效 1.2. 期货 与远期合约相同，在未来确定时间按确定价格交易一定量标的资产的协议 通常在交易所进行交易 有标准化条款 期货价格通常由场内交易决定，依赖于供求关系。 1.3. 期权 期权： 持有人在确定时间，按照确定价格向出售方购销一定原生资产的协议。但是他不承担必须购入或卖出的义务 名称 含义 实施价格或敲定价格 确定价格 到期日 确定日期 实施 按合约规定进行购买或销售 期权可以到期不予实施，是一种未定权益 期权需交纳期权金 期权定价是对这一类未定权益定价 1.4. 期权分类 名称 含义 看涨期权 在确定时间购入 看跌期权 在确定时间出售 欧式期权 只能在合约日期交易 美式期权 可以再确定日期之前的任意一天交易（工作日） 1.4.1. 5.交易者类型 可以分为三大类：对冲者（套期保值者）；投机者；套利者 对冲者： 利用期货或者期权来减小他们面临的风险（衍生品最初的意义） 一般利用远期合约或者期权进行对冲 远期合约是通过锁定买入或者卖出原生资产的价格进行对冲 期权产品是提供了价格保险，需要支付期权金。 投机者： 投机者通过对资产价格变动 下注 以小博大获利 期权给投资者提供了杠杆效应。也就是说，期权会方法最终的经济效果：好的收益会更好，坏的收益会更坏 套利者： 基于对同一类风险资产的观察，利用市场价格的差异，在不同的市场进行交易，获瞬时的无风险收益。 套利和投机的不同： 投机是基于对未来价格水平的预测以谋取利润，有风险； 但是逃离是利用不同市场在价格上的差异的现实，无风险 由于一旦有套利机会，必然有套利者参与，直至无套利，所以我们只讨论==无套利原理== ，即在不存在套利机会的基础上进行研究。 1.5. 利率 利率是决定几乎所有衍生产品价格的因素之一。 利率定义了在一定情况下 借入方 承诺支付给 借出方 的资金数量。 常用： 无风险利率 衍生产品定价一般是通过建立一个无风险又资组合，然后使瓯子组合的回报率等于无风险利率。 无风险利率组合 意味着站在任何一个时间点，该投资组合未来的价值是确定的，不是随机的。 一般来说，国债没有违约风险 利率的计算： eg. 年利率是 r ，复利 m 次，本金为 A 。 则一年的利息是 A×(1+rm)m−AA \\times (1+ \\frac{r}{m})^m-AA×(1+​m​​r​​)​m​​−A 连续复利： 当复利频率 m 接近无穷大的时候，对应的理律交 按连续复利 eg. 年利率为 r ，按连续复利计，金额 A 投资 x 年后将变成AerxAe^{rx}Ae​rx​​ 。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-26 14:30:34 "},"数理金融/fan-2.html":{"url":"数理金融/fan-2.html","title":"数理金融（二）","keywords":"","body":"1. 数理金融（二）1.1. 无套利原理1.1.1. 套利机会：1.1.2. 卖空：1.1.3. 金融市场与无套利原理1.2. 自融资1.3. 套利机会1.4. 一些定义1.5. 如何确定远期价格1.6. 其他1. 数理金融（二） 无套利原理及简单应用 1.1. 无套利原理 无套利原理是期权定价理论的基础。 我们假设不存在套利机会 1.1.1. 套利机会： 在 某时刻 ，客户 身无分文 进入市场，通过资产的买卖，允许买空和买空，是的最终不欠债，且有 正概率 的机会获得盈利。 1.1.2. 卖空： 卖出投资者并不拥有的财产 1.1.3. 金融市场与无套利原理 在 t 时刻，观察其后某一时刻的资产价格，无风险资产的价格是确定的，分析按资产的价格是不确定的，是一个随机变量。 在本课程中，除非特别指明，我们将假设无风险资产的年收益率为 r ，按连续复利计算，假设无风险资产在 $t0$ 时刻价格为 $B{t_0}$ ，则在 $t_1$ 时刻， Bt1=Bt0×er(t1−t0) B_{t_1}=B_{t_0}\\times e^{r(t_1-t_0)} B​t​1​​​​=B​t​0​​​​×e​r(t​1​​−t​0​​)​​ 反之，如果知道 无风险资产 在 t1t_1t​1​​ 时刻价格为 Bt1B_{t_1}B​t​1​​​​ ，那么在$t_0$ 时刻 Bt0=Bt1×e−r(t1−t0) B_{t_0}=B_{t_1}\\times e^{-r(t_1-t_0)} B​t​0​​​​=B​t​1​​​​×e​−r(t​1​​−t​0​​)​​ 即 以无风险利率r按连续复利进行 贴现。 1.2. 自融资 考虑有无风险资产和若干风险资产组成的 投资组合 （也称为投资策略）记为 Φ\\PhiΦ 。若在整个交易其[0,T]内，投资人没有追加新的资金，也没有资金被抽走，那么称 Φ\\PhiΦ是 自融资 的。 定义Vt(Φ)V_t(\\Phi)V​t​​(Φ) 是在 ψ\\psiψ 时刻 t 的 价值。 1.3. 套利机会 一个自融资策略称为在[0,T]内存在 套利机会 ，如果存在t∗∈[0,T)t^* \\in [0,T)t​∗​​∈[0,T)，使得Vt∗=0V_{t^*}=0V​t​∗​​​​=0 ，但VT⩾0V_T\\geqslant 0V​T​​⩾0 ，且 Prob{VT(Φ)⩾0}⩾0Prob\\{V_T(\\Phi) \\geqslant 0 \\}\\geqslant 0Prob{V​T​​(Φ)⩾0}⩾0 ,这里Prob{w}表示时间w发生的概率。 1.4. 一些定义 定义2.1 若对于任意自融资的头则策略在任意时段内都不存在套利机会，那么称市场在该时段内是无套利的。 定理2.1 若在一段时间内，无套利投资组合A 和B 满足：在时间段的最后时刻，A的获利比 B多，则对该时间段内任意时刻，A 的获利比 B多。 定理2.2 若爱某段时间内市场无套利，投资组合 A和 B 满足：在时间段最后时刻，A和 B的获利相同，则在任意时间，两者均相同。 推论2.3 若在某时间段 市场无套利，且投资组合 A 在时间段末的时刻的价值为确定的现金流 F ，则 F 以无风险利率r按连续复利贴现可以孙任意时刻的现金流。 推论2.3 的更一般情形 在某一时间段内市场无套利，且资产组合$\\psi$在[0,T]内的收益是在 $t_1,t_2$ 和T产生的确定的现金流 $A_1,A_2,A$，假设无风险利率为r，按连续复利及，资产组合$\\psi$在0时刻的价值等于 V0=A1e−rt1+A2e−rt2+Ae−rT V_0=A_1e^{-rt_1}+A_2e^{-rt_2}+Ae^{-rT} V​0​​=A​1​​e​−rt​1​​​​+A​2​​e​−rt​2​​​​+Ae​−rT​​ x1Bt1=Bt0×er(t1−t0) x1B_{t_1}=B_{t_0}\\times e^{r(t_1-t_0)} x1B​t​1​​​​=B​t​0​​​​×e​r(t​1​​−t​0​​)​​ 定理2.4 （定理2.1的更强版本）若在[0,T]内市场无套利，投资组合Φ1\\Phi_1Φ​1​​ Φ2\\Phi_2Φ​2​​ 满足，VT(Φ1)⩾VT(Φ2)V_T(\\Phi_1)\\geqslant V_T(\\Phi_2)V​T​​(Φ​1​​)⩾V​T​​(Φ​2​​) ,以及Prob{VT(Φ1)>VT(Φ2)}>0Prob\\{V_T(\\Phi_1)> V_T(\\Phi_2) \\}> 0Prob{V​T​​(Φ​1​​)>V​T​​(Φ​2​​)}>0 ,那么对任意时刻t∈[0,T)t \\in [0,T)t∈[0,T) ，必有 Vt(Φ1)>Vt(Φ2) V_t(\\Phi_1)> V_t(\\Phi_2) V​t​​(Φ​1​​)>V​t​​(Φ​2​​) 我们经常通过反证法来证明市场无套利 1.5. 如何确定远期价格 一般方法： 通过买入以单位的原生资产和进入远期合约空头构造无风险的投资组合。 由于市场是无套利的，根据推论2.4，该无风险投资组合在0时刻的价格等于T时刻的价格以无风险利率 r 安连续复利贴现，从而我们可以求出远期价格 三种情形： 1.6. 其他 股指： 股指一般可以被看作支付股息的投资资产。 远期价格与远期合约价值： 一种资产的远期价格是交易员在进入合约时刻约定的在未来以此买入或者卖出的该资产的价格。 刚进入的时候，价值为0，随着时间的推移，会变化，可能为正也可能为负 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-26 14:42:14 "},"数理金融/fan-3.html":{"url":"数理金融/fan-3.html","title":"数理金融（三）","keywords":"","body":"1. 数理金融（三）1.1. 期权价格的上限1.2. 股息对欧式期权价格的影响1.2.1. 3.美式期权价格的下限：1. 数理金融（三） 有无股息的欧式和美式看跌看涨期权 记号 含义 StS_tS​t​​ 原生资产价格（为简单计，以下都认为是股价） ctc_tc​t​​ 欧式看涨期权价格 ptp_tp​t​​ 欧式看跌期权价格 CtC_tC​t​​ 美式看涨期权价格 PtP_tP​t​​ 美式看跌期权 K 期权敲定价格 T 到期日 r 无风险利率（按连续复利计） 1.1. 期权价格的上限 欧式或 者美式 看涨期权 给持有人以敲定价格买入一只股票的权利。所以金融直观上，无论什么情况 ct⩽St;Ct⩽St,∀t∈[0,T] c_t\\leqslant S_t;C_t\\leqslant S_t ,\\forall t\\in [0,T] c​t​​⩽S​t​​;C​t​​⩽S​t​​,∀t∈[0,T] 证明由 定理2.1 欧式或者美式 看跌期权 给持有人以敲定价格出售一只股票的权利。无论什么情况，看跌期权的价格都不会超出执行价格，因此 pt⩽K,Pt⩽K,∀t∈[0,T] p_t\\leqslant K,P_t\\leqslant K,\\forall t\\in [0,T] p​t​​⩽K,P​t​​⩽K,∀t∈[0,T] 对于欧式看跌期权，我们可以得到一个更准确的上界： $\\Phi_1$ :持有一张欧式看跌期权 $\\Phi_2$ :持有在到期日T收益为K的无风险资产 VT(Φ1)=(K=ST)+⩽K=VT(Φ2) V_T(\\Phi_1)=(K=S_T)^+\\leqslant K=V_T(\\Phi_2) V​T​​(Φ​1​​)=(K=S​T​​)​+​​⩽K=V​T​​(Φ​2​​) 无股息 欧式看涨期权价格的下限： ct⩾(St−Ke−r(T−t))+,∀t∈[0,T] c_t\\geqslant (S_t-Ke^{-r(T-t)})^+ ,\\forall t\\in [0,T] c​t​​⩾(S​t​​−Ke​−r(T−t)​​)​+​​,∀t∈[0,T] 无股息 欧式看跌期权价格的下限： pt⩾(Ke−r(T−t)−St)+,∀t∈[0,T] p_t\\geqslant (Ke^{-r(T-t)}-S_t)^+,\\forall t\\in [0,T] p​t​​⩾(Ke​−r(T−t)​​−S​t​​)​+​​,∀t∈[0,T] 看涨-看跌欧式期权的 平价公式 ct+Ke−r(T−t)=pt+St,∀t∈[0,T] c_t+Ke^{-r(T-t)}=p_t+S_t,\\forall t\\in [0,T] c​t​​+Ke​−r(T−t)​​=p​t​​+S​t​​,∀t∈[0,T] 这个公式非常重要，表明对于两张具有相同有效期，相同敲定价格的偶是看涨和看跌期权，只要知道其中任意一张期权的价格，由平价公式就可以的得到另一张期权的价格。 评价公式 不需要对股票价格模型提出假设 ，唯一的要求是无套利原理。 ：本节课只在无套利原理下研究。 1.2. 股息对欧式期权价格的影响 我们用 D 来表示期权期限内的股息在0时刻的贴现值 欧式看涨期权价格的下限： c0⩾(S0−D−KerT)+ c_0\\geqslant (S_0-D-Ke^{rT})^+ c​0​​⩾(S​0​​−D−Ke​rT​​)​+​​ 欧式看跌期权价格的下限： p0⩾(D+KerT−S0)+ p_0\\geqslant (D+Ke^{rT}-S_0)^+ p​0​​⩾(D+Ke​rT​​−S​0​​)​+​​ D是期权期限内(0,T)的股息在0时刻的贴现值。 注意 ：股息使看跌期权价格增加，而使看涨期权价格减少，原因是股息将使股票在除息日的价格降低，从而导致股票在期权到期日的价格降低。 股息 对看涨-看跌欧式期权的评价公式的影响： 我们用 D 来表示期权期限内(0,T)的股息在0时刻的贴现值，则 c0+D+Ke−rT=p0+S0 c_0+D+Ke^{-rT}=p_0+S_0 c​0​​+D+Ke​−rT​​=p​0​​+S​0​​ 1.2.1. 3.美式期权价格的下限： 1.美式期权有提前实施的条款，因此美式期权总是比相应欧式期权贵 Ct⩾ct,Pt⩾pt,∀t∈[0,T] C_t\\geqslant c_t,P_t\\geqslant p_t,\\forall t\\in [0,T] C​t​​⩾c​t​​,P​t​​⩾p​t​​,∀t∈[0,T] 结论： 无股息时，投资者在到期日之前实施股票上的美式看涨期权永远不是最优选择！ 2.无股息时，美式看涨期权本质上和欧式看涨期权是等价的 3.有股息时，提早实施美式看涨期权 有可能是 最优的。 4.无股息 的 美式看跌期权 的价格下限： Pt⩾(K−St)+,∀t∈[0,T] P_t\\geqslant (K-S_t)^+,\\forall t\\in [0,T] P​t​​⩾(K−S​t​​)​+​​,∀t∈[0,T] 也就是说，在没有股息的情况下，持有人更倾向于提前实施 5.有股息 的 美式看跌期权 价格下限： Pt⩾max{(D+Ke−rT−S0)+,(K−St)+},∀t∈[0,T] P_t\\geqslant max\\{(D+Ke^{-rT}-S_0)^+,(K-S_t)^+ \\},\\forall t\\in [0,T] P​t​​⩾max{(D+Ke​−rT​​−S​0​​)​+​​,(K−S​t​​)​+​​},∀t∈[0,T] 6.美式看涨-看跌期权的“平价公式” 当没有股息的时候： St−K⩽Ct−Pt⩽St=Ke−r(T−t),∀t∈[0,T] S_t-K\\leqslant C_t-P_t\\leqslant S_t=Ke^{-r(T-t)},\\forall t\\in [0,T] S​t​​−K⩽C​t​​−P​t​​⩽S​t​​=Ke​−r(T−t)​​,∀t∈[0,T] 当有股息的时候： S0−D−K⩽C0−P0⩽S0−Ke−rT S_0-D-K\\leqslant C_0-P_0\\leqslant S_0-Ke^{-rT} S​0​​−D−K⩽C​0​​−P​0​​⩽S​0​​−Ke​−rT​​ By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-26 14:48:18 "},"数理金融/fan-4.html":{"url":"数理金融/fan-4.html","title":"数理金融（四）","keywords":"","body":"1. 数理金融（四）1.1. 概述1.2. 以欧式看涨期权为例1.3. 单步二叉树期权定价1.4. 风险中性定价理论1.5. 风险中性定价1. 数理金融（四） 二叉树模型 1.1. 概述 期权定价的离散时间模型——二叉树模型 优点：简单直观、不需要太高深的数学知识、是一种非常有效且流行的定价方法。 概述： 二叉树是用来描述期权期限内股票价格变动的可能路径 这种方法假设了股票价格仅在离散时间点上发生变化，并且假设股票价格服从 随机游走 ，即在每个离散的时间点以概率 p 上升到上一步价格的 u 倍或者以概率 (1-p) 下降到上一步价格的 d 倍。 1.2. 以欧式看涨期权为例 题目： 现有一只股票，当前价格为10元 3个月后股票 的价格变化仅有两种可能性，即可能涨至12元，也可能跌到 8元。 那么以一股该股票为标的，行权价为11元，3个月后到 期的欧式看涨期权现在价格应该是多少呢？ 思考以及解题： 建立投资组合$\\Phi$：持有 A 只股票，同时卖出一份以一股该股票为标的资产的看涨期权。 这时候，该投资组合是 无风险组合 股票价格 上涨为12元 下跌至8元 投资组合的价值 12 A-1 8 A 由于 无风险组合 ，那么 投资组合在上述两种情况的终端价值相等 所以 12A−1=8A12A-1=8A12A−1=8A ,可以求出 A=0.25 由于投资组合 无风险 ，并且 市场无套利 ，因此收益率等于无风险收益率。 根据无风险收益率是 4% ，那么投资组合 现值是 2元的贴现值(涨跌幅) 根据 按连续复利计无套利公式 2e−0.04×3/122e^{-0.04\\times 3/12}2e​−0.04×3/12​​ =1.98 我们假设期权当前的价格是 f 。 那么现在手中实际的资产是 0.25×10(手中所含有的股票资产)-f(购买期权用掉的资产)=2.5-f，这部分资产相当于之前按连续复利计算的1.98，由此可以求出 f 。 1.3. 单步二叉树期权定价 问题： 股票当前价格：S0S_0S​0​​ ;看涨期权当前价格： f ；期权有效期： T ； 解： 我们建立一个无风险投资组合： 买入 A 只股票，卖出一份以一只股票为标的的看涨期权。 那么投资组合的价值： 上涨 下跌 AuS0−fuAuS_0-f_uAuS​0​​−f​u​​ AdS0−fdAdS_0-f_dAdS​0​​−f​d​​ 两个投资组合的价值应该是相等的，由此可以计算出 A ，然后我们可以通过上涨的投资组合的价值进行无套利原理贴现，最后计算出当前价值。 股票数量A其实是 期权价格差÷股价差 上面的构造无风险投资组合的方法叫做 Delta对冲 1.4. 风险中性定价理论 当股票满足一不二茶模型的时候，根据无套利原理 ，我们可以计算期权价格： f=[pfu+(1−p)fd]erTf=[pf_u+(1-p)f_d]e^{rT}f=[pf​u​​+(1−p)f​d​​]e​rT​​ ，其中 p=erT−du−dp=\\frac{e^{rT}-d}{u-d}p=​u−d​​e​rT​​−d​​ ，我们定义p是上涨概率。 也就是说，期权的价格等于在到期日的价格期望的贴现值 。 同时，假设股票价格上涨的概率 p 实际上是 假设股票的期望收益率是无风险利率。 p 也被称为风险中性概率。 1.5. 风险中性定价 第一步： puS0+(1−p)dS0=S0erTpuS_0+(1-p)dS_0=S_0e^{rT}puS​0​​+(1−p)dS​0​​=S​0​​e​rT​​ 第二步：计算期权在到期日的风险中性期望 第三步：无风险利率贴现 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-26 14:53:48 "},"数理金融/fan-5.html":{"url":"数理金融/fan-5.html","title":"数理金融（五）","keywords":"","body":"1. 数理金融（五）1.1. 二叉树模型1.2. 多步二叉树1. 数理金融（五） 二叉树和多步二叉树 1.1. 二叉树模型 无套利均衡定价方法： 卖出一份齐全，同时买入 $\\Delta$ 股标的股票构造无风险投资组合，这样构造 无风险投资组合 的方法我们也称之为 Delta对冲。 风险中性定价方法： 在风险中性世界中，所有证券（包括股票和期权）的期望收益率都等于无风险利率： 利用股票的期望收益率为无风险利率确定风险中性概率为p=erT−du−dp= \\frac{e^{rT}-d}{u-d}p=​u−d​​e​rT​​−d​​ 计算到期日期权价格的风险中性期望，再以无风险利率进行贴现即可得到期权的价格。 ：当股票不支付股息时，美式看涨期权he欧式看涨期权的价格是一样的。 在一步或者二步二叉树模型中：期权的价格只与三个变量有关：无风险利率、股票价格在每一步的上涨和下跌幅度。 1.2. 多步二叉树 方法：从二叉树的 末端 多利用风险中性加工时一步步向前推导每个节点的期权。 By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-26 14:57:37 "},"数理金融/fan-6.html":{"url":"数理金融/fan-6.html","title":"数理金融（六）","keywords":"","body":"1. 数理金融（六）1.1.1. 布朗运动1.1.2. Ito过程与Ito积分1.1.3. Black-schols方程的推导和应用1. 数理金融（六） 关于股票价格的连续时间 随机过程 1.1.1. 布朗运动 什么是布朗运动 一个随机过程w(t) 称为 标准布朗运动，如果满足以下性质： w(0)=0,w(t)关于时间连续 在给定的长度为Δt\\Delta tΔt​​的时间区间上， w(t)的变化量Δw\\Delta wΔw​​服从期望为0、方差为Δt\\Delta tΔt​​的正态分布，即Δw=Δtϕ,ϕ∼N(0,1)\\Delta w=\\sqrt{\\Delta t} \\phi ,\\phi \\sim N(0,1)Δw=√​Δt​​​ϕ,ϕ∼N(0,1)​​ 。 在任意两个不互相重叠的时间区间上，变化量\\Delta w是相互独立的。 第三个性质说明， w(t)服从马尔可夫过程，即w(t)在未来的概率分布只与当前值有关，而不依赖于在过去所遵循的特定路径。换句话说，该过程的当前值包含了对其未来做预测所需的全部信息。 利用matlab模拟[0,T]布朗运动 T=1; dt=1/1000; N=1001; W=zeros(N,1); for i=2:N W(i)=W(i-1)+sqrt(dt)*randn; % randn是生成标准正态随机变量 end plot([0:dt:T],W) 布朗运动的一些应用 一维布朗运动的走势和股票价格曲线的走势看着非常相似，这变引起人们利用它来描述股票价格走势的兴趣。 布朗运动 {w(t),t≥0}\\{w (t) , t \\geq 0\\}{w(t),t≥0} 的每一条轨道看起来是不光滑的，甚至是杂乱无章的，但它们是连续的。 值得注意的是布朗运动{w(t),t≥0}\\{w (t) , t \\geq 0\\}{w(t),t≥0} 的轨道是不可微的。 事实上，P(limΔt→0∣ΔWtΔt>x)=1P( lim_{ \\Delta t \\rightarrow 0}|\\frac {\\Delta W_t}{\\Delta t}> x)=1P(lim​Δt→0​​∣​Δt​​ΔW​t​​​​>x)=1​​ 1.1.2. Ito过程与Ito积分 相关定义 我们定义xt为Ito过程，如果: dxt=a(xt,t)dt+b(xt,t)dwtdx_t = a(x_t, t)dt + b(x_t, t)dw_tdx​t​​=a(x​t​​,t)dt+b(x​t​​,t)dw​t​​ dwtdw_tdw​t​​是标准布朗运动$W_t$在t时刻的瞬间改变量，dwtdw_tdw​t​​ ~ N(0,dt)N(0, dt)N(0,dt). a(xt,t)dta(x_t, t) dta(x​t​​,t)dt和b(xt,t)dtb (x_t, t) dtb(x​t​​,t)dt可以理解为xtx_tx​t​​ 在t时刻的瞬间改变量的期望值和方差。&#x1D44E;称为过程xtx_tx​t​​的漂移率，&#x1D44F;称为xtx_tx​t​​ 的扩散率。、 股票价格过程 标准布朗运动不是描述股价运动的最佳选择：因为在任意一个时间区间上改变量的期望都是0. 在衍生产品定价中，我们假设服从 Black-sholes模型 dSt=μStdt+σStdwt dS_t=\\mu S_tdt+\\sigma S_tdw_t dS​t​​=μS​t​​dt+σS​t​​dw​t​​ μ,σ\\mu,\\sigmaμ,σ是常数 dStdS_tdS​t​​是资产价格在无穷小的时间间隔内的变化量 dSt/StdS_t/S_tdS​t​​/S​t​​是这段时间内的收益率 所以 dSt/St=μdt+σdwtdS_t/S_t=\\mu dt+\\sigma dw_tdS​t​​/S​t​​=μdt+σdw​t​​ 这里称StS_tS​t​​是一个 几何布朗运动；μ\\muμ 被称作资产阶级的期望收益率； σ\\sigmaσ 被称为资产阶级的波动率。 Ito定理 假定 G(St,t)G(S_t,t)G(S​t​​,t)是t和StS_tS​t​​ 的二元函数，StS_tS​t​​ 服从Ito过程 dSt=a(St,t)dt+b(St,t)dWt dS_t=a(S_t,t)dt+b(S_t,t)dW_t dS​t​​=a(S​t​​,t)dt+b(S​t​​,t)dW​t​​ Ito定理的应用 用Ito定理计算 Ito积分 1.1.3. Black-schols方程的推导和应用 假设股票价格遵循几何布朗运动，即 dS=μSdt+σSdW dS=\\mu Sdt+\\sigma SdW dS=μSdt+σSdW 假定f为依赖于S的衍生产品价格，f(S,t)，根据Ito定理 近似离散形式： ΔS=μSΔt+σSΔdW \\Delta S=\\mu S\\Delta t+\\sigma S\\Delta dW ΔS=μSΔt+σSΔdW 由于投资组合在长度为\\Delta t的时间上市无风险的，根据无套利原理，无风险投资组合的收益率等于无风险收益率，所以有 欧式看涨期权的价格满足BC方程，其终值条件：f(S,T)=(S−K)+f(S,T)=(S-K)^+f(S,T)=(S−K)​+​​ 欧式看跌期权的价格满足BC方程，其终值条件：f(S,T)=(K−S)+f(S,T)=(K-S)^+f(S,T)=(K−S)​+​​ 注： 在BC方程中并未出现股票在真实世界里的期望回报率μ\\muμ ，代替的是无风险收益率，因此BC得到的期权价格和μ\\muμ无关 通过求解 BC方程，欧式看涨与看跌期权的价格如下： By 星客，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-07-26 16:24:01 "}}