# 视图


## **定义视图**

### **建立视图**

```sql
 CREATE VIEW <视图名>[(<列名>[,<列名>]...)]
 AS<子查询>
 [WITH CHECK OPTION];
```

其中，子查询可以是任意的SELECT语句

组成视图的属性列名要么全部指定要么全部省略

以下三种情况必修指定：

1. 某个目标列不是单纯的属性名，是聚集函数或者列表达式
2. 多表连接的时候选出了几个同名列作为视图的字段
3. 需要在视图中为某个列启用更合适的名字

若一个视图侍从单个表中导出的，并且只是去掉了基本表的某些行和某些列，但是保留了主码。则称这列视图是行列子集视图

视图不仅可以建立在一个或者多个基本表上，还可以建立在一个或者多个已经定义好的视图上，或者建立在基本表与视图上

带虚拟列的视图也称为带表达式的视图

带有聚集函数和GROUP BY子句的查询来定义视图，这种视图被称为分组视图

### **删除视图**

```sql
 DROP VIEW<视图名>[CASCADE]
```

## **查询视图**

从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询。然后在执行修正了的查询，这一过程被称为视图消解

WHERE子句不能用聚集函数作为条件表达式，所以执行此修正后的查询将会出现语法错误，可以转化为GROUP BY

定义视图并查询视图 与 基于派生表的查询是有区别的。派生表是暂时的，而视图存在于数据字典中

## **更新视图**

视图是不实际存储数据的虚表，对视图的更新最重要转换为对基本表的更新

并不是所有的视图都可以更新

一般的，行列子集视图是可更新的

不可更新视图≠不允许更新视图

## **视图的作用**

1.简化用户的操作

2.使用户能以所种角度看待同一数据

3.随重构数据库提供了一定程度的逻辑独立性

4.对机密数据提供安全保护

5.适当利用视图可以更清理的表达查询
